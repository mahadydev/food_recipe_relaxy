// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'recipe_details.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

RecipeDetails _$RecipeDetailsFromJson(Map<String, dynamic> json) {
  return _RecipeDetails.fromJson(json);
}

/// @nodoc
mixin _$RecipeDetails {
  bool? get vegetarian => throw _privateConstructorUsedError;
  bool? get vegan => throw _privateConstructorUsedError;
  bool? get glutenFree => throw _privateConstructorUsedError;
  bool? get dairyFree => throw _privateConstructorUsedError;
  bool? get veryHealthy => throw _privateConstructorUsedError;
  bool? get cheap => throw _privateConstructorUsedError;
  bool? get veryPopular => throw _privateConstructorUsedError;
  bool? get sustainable => throw _privateConstructorUsedError;
  bool? get lowFodmap => throw _privateConstructorUsedError;
  int? get weightWatcherSmartPoints => throw _privateConstructorUsedError;
  String? get gaps => throw _privateConstructorUsedError;
  int? get preparationMinutes => throw _privateConstructorUsedError;
  int? get cookingMinutes => throw _privateConstructorUsedError;
  int? get aggregateLikes => throw _privateConstructorUsedError;
  int? get healthScore => throw _privateConstructorUsedError;
  String? get creditsText => throw _privateConstructorUsedError;
  String? get sourceName => throw _privateConstructorUsedError;
  double? get pricePerServing => throw _privateConstructorUsedError;
  List<ExtendedIngredient>? get extendedIngredients =>
      throw _privateConstructorUsedError;
  int? get id => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  int? get readyInMinutes => throw _privateConstructorUsedError;
  int? get servings => throw _privateConstructorUsedError;
  String? get sourceUrl => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;
  String? get imageType => throw _privateConstructorUsedError;
  Taste? get taste => throw _privateConstructorUsedError;
  String? get summary => throw _privateConstructorUsedError;
  List<dynamic>? get cuisines => throw _privateConstructorUsedError;
  List<String>? get dishTypes => throw _privateConstructorUsedError;
  List<String>? get diets => throw _privateConstructorUsedError;
  List<dynamic>? get occasions => throw _privateConstructorUsedError;
  WinePairing? get winePairing => throw _privateConstructorUsedError;
  String? get instructions => throw _privateConstructorUsedError;
  List<AnalyzedInstruction>? get analyzedInstructions =>
      throw _privateConstructorUsedError;
  dynamic get originalId => throw _privateConstructorUsedError;
  double? get spoonacularScore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RecipeDetailsCopyWith<RecipeDetails> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecipeDetailsCopyWith<$Res> {
  factory $RecipeDetailsCopyWith(
          RecipeDetails value, $Res Function(RecipeDetails) then) =
      _$RecipeDetailsCopyWithImpl<$Res, RecipeDetails>;
  @useResult
  $Res call(
      {bool? vegetarian,
      bool? vegan,
      bool? glutenFree,
      bool? dairyFree,
      bool? veryHealthy,
      bool? cheap,
      bool? veryPopular,
      bool? sustainable,
      bool? lowFodmap,
      int? weightWatcherSmartPoints,
      String? gaps,
      int? preparationMinutes,
      int? cookingMinutes,
      int? aggregateLikes,
      int? healthScore,
      String? creditsText,
      String? sourceName,
      double? pricePerServing,
      List<ExtendedIngredient>? extendedIngredients,
      int? id,
      String? title,
      int? readyInMinutes,
      int? servings,
      String? sourceUrl,
      String? image,
      String? imageType,
      Taste? taste,
      String? summary,
      List<dynamic>? cuisines,
      List<String>? dishTypes,
      List<String>? diets,
      List<dynamic>? occasions,
      WinePairing? winePairing,
      String? instructions,
      List<AnalyzedInstruction>? analyzedInstructions,
      dynamic originalId,
      double? spoonacularScore});

  $TasteCopyWith<$Res>? get taste;
  $WinePairingCopyWith<$Res>? get winePairing;
}

/// @nodoc
class _$RecipeDetailsCopyWithImpl<$Res, $Val extends RecipeDetails>
    implements $RecipeDetailsCopyWith<$Res> {
  _$RecipeDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vegetarian = freezed,
    Object? vegan = freezed,
    Object? glutenFree = freezed,
    Object? dairyFree = freezed,
    Object? veryHealthy = freezed,
    Object? cheap = freezed,
    Object? veryPopular = freezed,
    Object? sustainable = freezed,
    Object? lowFodmap = freezed,
    Object? weightWatcherSmartPoints = freezed,
    Object? gaps = freezed,
    Object? preparationMinutes = freezed,
    Object? cookingMinutes = freezed,
    Object? aggregateLikes = freezed,
    Object? healthScore = freezed,
    Object? creditsText = freezed,
    Object? sourceName = freezed,
    Object? pricePerServing = freezed,
    Object? extendedIngredients = freezed,
    Object? id = freezed,
    Object? title = freezed,
    Object? readyInMinutes = freezed,
    Object? servings = freezed,
    Object? sourceUrl = freezed,
    Object? image = freezed,
    Object? imageType = freezed,
    Object? taste = freezed,
    Object? summary = freezed,
    Object? cuisines = freezed,
    Object? dishTypes = freezed,
    Object? diets = freezed,
    Object? occasions = freezed,
    Object? winePairing = freezed,
    Object? instructions = freezed,
    Object? analyzedInstructions = freezed,
    Object? originalId = freezed,
    Object? spoonacularScore = freezed,
  }) {
    return _then(_value.copyWith(
      vegetarian: freezed == vegetarian
          ? _value.vegetarian
          : vegetarian // ignore: cast_nullable_to_non_nullable
              as bool?,
      vegan: freezed == vegan
          ? _value.vegan
          : vegan // ignore: cast_nullable_to_non_nullable
              as bool?,
      glutenFree: freezed == glutenFree
          ? _value.glutenFree
          : glutenFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      dairyFree: freezed == dairyFree
          ? _value.dairyFree
          : dairyFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryHealthy: freezed == veryHealthy
          ? _value.veryHealthy
          : veryHealthy // ignore: cast_nullable_to_non_nullable
              as bool?,
      cheap: freezed == cheap
          ? _value.cheap
          : cheap // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryPopular: freezed == veryPopular
          ? _value.veryPopular
          : veryPopular // ignore: cast_nullable_to_non_nullable
              as bool?,
      sustainable: freezed == sustainable
          ? _value.sustainable
          : sustainable // ignore: cast_nullable_to_non_nullable
              as bool?,
      lowFodmap: freezed == lowFodmap
          ? _value.lowFodmap
          : lowFodmap // ignore: cast_nullable_to_non_nullable
              as bool?,
      weightWatcherSmartPoints: freezed == weightWatcherSmartPoints
          ? _value.weightWatcherSmartPoints
          : weightWatcherSmartPoints // ignore: cast_nullable_to_non_nullable
              as int?,
      gaps: freezed == gaps
          ? _value.gaps
          : gaps // ignore: cast_nullable_to_non_nullable
              as String?,
      preparationMinutes: freezed == preparationMinutes
          ? _value.preparationMinutes
          : preparationMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      cookingMinutes: freezed == cookingMinutes
          ? _value.cookingMinutes
          : cookingMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      aggregateLikes: freezed == aggregateLikes
          ? _value.aggregateLikes
          : aggregateLikes // ignore: cast_nullable_to_non_nullable
              as int?,
      healthScore: freezed == healthScore
          ? _value.healthScore
          : healthScore // ignore: cast_nullable_to_non_nullable
              as int?,
      creditsText: freezed == creditsText
          ? _value.creditsText
          : creditsText // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceName: freezed == sourceName
          ? _value.sourceName
          : sourceName // ignore: cast_nullable_to_non_nullable
              as String?,
      pricePerServing: freezed == pricePerServing
          ? _value.pricePerServing
          : pricePerServing // ignore: cast_nullable_to_non_nullable
              as double?,
      extendedIngredients: freezed == extendedIngredients
          ? _value.extendedIngredients
          : extendedIngredients // ignore: cast_nullable_to_non_nullable
              as List<ExtendedIngredient>?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      readyInMinutes: freezed == readyInMinutes
          ? _value.readyInMinutes
          : readyInMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      servings: freezed == servings
          ? _value.servings
          : servings // ignore: cast_nullable_to_non_nullable
              as int?,
      sourceUrl: freezed == sourceUrl
          ? _value.sourceUrl
          : sourceUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      imageType: freezed == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as String?,
      taste: freezed == taste
          ? _value.taste
          : taste // ignore: cast_nullable_to_non_nullable
              as Taste?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      cuisines: freezed == cuisines
          ? _value.cuisines
          : cuisines // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      dishTypes: freezed == dishTypes
          ? _value.dishTypes
          : dishTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      diets: freezed == diets
          ? _value.diets
          : diets // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      occasions: freezed == occasions
          ? _value.occasions
          : occasions // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      winePairing: freezed == winePairing
          ? _value.winePairing
          : winePairing // ignore: cast_nullable_to_non_nullable
              as WinePairing?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      analyzedInstructions: freezed == analyzedInstructions
          ? _value.analyzedInstructions
          : analyzedInstructions // ignore: cast_nullable_to_non_nullable
              as List<AnalyzedInstruction>?,
      originalId: freezed == originalId
          ? _value.originalId
          : originalId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      spoonacularScore: freezed == spoonacularScore
          ? _value.spoonacularScore
          : spoonacularScore // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TasteCopyWith<$Res>? get taste {
    if (_value.taste == null) {
      return null;
    }

    return $TasteCopyWith<$Res>(_value.taste!, (value) {
      return _then(_value.copyWith(taste: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $WinePairingCopyWith<$Res>? get winePairing {
    if (_value.winePairing == null) {
      return null;
    }

    return $WinePairingCopyWith<$Res>(_value.winePairing!, (value) {
      return _then(_value.copyWith(winePairing: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RecipeDetailsImplCopyWith<$Res>
    implements $RecipeDetailsCopyWith<$Res> {
  factory _$$RecipeDetailsImplCopyWith(
          _$RecipeDetailsImpl value, $Res Function(_$RecipeDetailsImpl) then) =
      __$$RecipeDetailsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool? vegetarian,
      bool? vegan,
      bool? glutenFree,
      bool? dairyFree,
      bool? veryHealthy,
      bool? cheap,
      bool? veryPopular,
      bool? sustainable,
      bool? lowFodmap,
      int? weightWatcherSmartPoints,
      String? gaps,
      int? preparationMinutes,
      int? cookingMinutes,
      int? aggregateLikes,
      int? healthScore,
      String? creditsText,
      String? sourceName,
      double? pricePerServing,
      List<ExtendedIngredient>? extendedIngredients,
      int? id,
      String? title,
      int? readyInMinutes,
      int? servings,
      String? sourceUrl,
      String? image,
      String? imageType,
      Taste? taste,
      String? summary,
      List<dynamic>? cuisines,
      List<String>? dishTypes,
      List<String>? diets,
      List<dynamic>? occasions,
      WinePairing? winePairing,
      String? instructions,
      List<AnalyzedInstruction>? analyzedInstructions,
      dynamic originalId,
      double? spoonacularScore});

  @override
  $TasteCopyWith<$Res>? get taste;
  @override
  $WinePairingCopyWith<$Res>? get winePairing;
}

/// @nodoc
class __$$RecipeDetailsImplCopyWithImpl<$Res>
    extends _$RecipeDetailsCopyWithImpl<$Res, _$RecipeDetailsImpl>
    implements _$$RecipeDetailsImplCopyWith<$Res> {
  __$$RecipeDetailsImplCopyWithImpl(
      _$RecipeDetailsImpl _value, $Res Function(_$RecipeDetailsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? vegetarian = freezed,
    Object? vegan = freezed,
    Object? glutenFree = freezed,
    Object? dairyFree = freezed,
    Object? veryHealthy = freezed,
    Object? cheap = freezed,
    Object? veryPopular = freezed,
    Object? sustainable = freezed,
    Object? lowFodmap = freezed,
    Object? weightWatcherSmartPoints = freezed,
    Object? gaps = freezed,
    Object? preparationMinutes = freezed,
    Object? cookingMinutes = freezed,
    Object? aggregateLikes = freezed,
    Object? healthScore = freezed,
    Object? creditsText = freezed,
    Object? sourceName = freezed,
    Object? pricePerServing = freezed,
    Object? extendedIngredients = freezed,
    Object? id = freezed,
    Object? title = freezed,
    Object? readyInMinutes = freezed,
    Object? servings = freezed,
    Object? sourceUrl = freezed,
    Object? image = freezed,
    Object? imageType = freezed,
    Object? taste = freezed,
    Object? summary = freezed,
    Object? cuisines = freezed,
    Object? dishTypes = freezed,
    Object? diets = freezed,
    Object? occasions = freezed,
    Object? winePairing = freezed,
    Object? instructions = freezed,
    Object? analyzedInstructions = freezed,
    Object? originalId = freezed,
    Object? spoonacularScore = freezed,
  }) {
    return _then(_$RecipeDetailsImpl(
      vegetarian: freezed == vegetarian
          ? _value.vegetarian
          : vegetarian // ignore: cast_nullable_to_non_nullable
              as bool?,
      vegan: freezed == vegan
          ? _value.vegan
          : vegan // ignore: cast_nullable_to_non_nullable
              as bool?,
      glutenFree: freezed == glutenFree
          ? _value.glutenFree
          : glutenFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      dairyFree: freezed == dairyFree
          ? _value.dairyFree
          : dairyFree // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryHealthy: freezed == veryHealthy
          ? _value.veryHealthy
          : veryHealthy // ignore: cast_nullable_to_non_nullable
              as bool?,
      cheap: freezed == cheap
          ? _value.cheap
          : cheap // ignore: cast_nullable_to_non_nullable
              as bool?,
      veryPopular: freezed == veryPopular
          ? _value.veryPopular
          : veryPopular // ignore: cast_nullable_to_non_nullable
              as bool?,
      sustainable: freezed == sustainable
          ? _value.sustainable
          : sustainable // ignore: cast_nullable_to_non_nullable
              as bool?,
      lowFodmap: freezed == lowFodmap
          ? _value.lowFodmap
          : lowFodmap // ignore: cast_nullable_to_non_nullable
              as bool?,
      weightWatcherSmartPoints: freezed == weightWatcherSmartPoints
          ? _value.weightWatcherSmartPoints
          : weightWatcherSmartPoints // ignore: cast_nullable_to_non_nullable
              as int?,
      gaps: freezed == gaps
          ? _value.gaps
          : gaps // ignore: cast_nullable_to_non_nullable
              as String?,
      preparationMinutes: freezed == preparationMinutes
          ? _value.preparationMinutes
          : preparationMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      cookingMinutes: freezed == cookingMinutes
          ? _value.cookingMinutes
          : cookingMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      aggregateLikes: freezed == aggregateLikes
          ? _value.aggregateLikes
          : aggregateLikes // ignore: cast_nullable_to_non_nullable
              as int?,
      healthScore: freezed == healthScore
          ? _value.healthScore
          : healthScore // ignore: cast_nullable_to_non_nullable
              as int?,
      creditsText: freezed == creditsText
          ? _value.creditsText
          : creditsText // ignore: cast_nullable_to_non_nullable
              as String?,
      sourceName: freezed == sourceName
          ? _value.sourceName
          : sourceName // ignore: cast_nullable_to_non_nullable
              as String?,
      pricePerServing: freezed == pricePerServing
          ? _value.pricePerServing
          : pricePerServing // ignore: cast_nullable_to_non_nullable
              as double?,
      extendedIngredients: freezed == extendedIngredients
          ? _value._extendedIngredients
          : extendedIngredients // ignore: cast_nullable_to_non_nullable
              as List<ExtendedIngredient>?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      readyInMinutes: freezed == readyInMinutes
          ? _value.readyInMinutes
          : readyInMinutes // ignore: cast_nullable_to_non_nullable
              as int?,
      servings: freezed == servings
          ? _value.servings
          : servings // ignore: cast_nullable_to_non_nullable
              as int?,
      sourceUrl: freezed == sourceUrl
          ? _value.sourceUrl
          : sourceUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      imageType: freezed == imageType
          ? _value.imageType
          : imageType // ignore: cast_nullable_to_non_nullable
              as String?,
      taste: freezed == taste
          ? _value.taste
          : taste // ignore: cast_nullable_to_non_nullable
              as Taste?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as String?,
      cuisines: freezed == cuisines
          ? _value._cuisines
          : cuisines // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      dishTypes: freezed == dishTypes
          ? _value._dishTypes
          : dishTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      diets: freezed == diets
          ? _value._diets
          : diets // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      occasions: freezed == occasions
          ? _value._occasions
          : occasions // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      winePairing: freezed == winePairing
          ? _value.winePairing
          : winePairing // ignore: cast_nullable_to_non_nullable
              as WinePairing?,
      instructions: freezed == instructions
          ? _value.instructions
          : instructions // ignore: cast_nullable_to_non_nullable
              as String?,
      analyzedInstructions: freezed == analyzedInstructions
          ? _value._analyzedInstructions
          : analyzedInstructions // ignore: cast_nullable_to_non_nullable
              as List<AnalyzedInstruction>?,
      originalId: freezed == originalId
          ? _value.originalId
          : originalId // ignore: cast_nullable_to_non_nullable
              as dynamic,
      spoonacularScore: freezed == spoonacularScore
          ? _value.spoonacularScore
          : spoonacularScore // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RecipeDetailsImpl implements _RecipeDetails {
  const _$RecipeDetailsImpl(
      {this.vegetarian,
      this.vegan,
      this.glutenFree,
      this.dairyFree,
      this.veryHealthy,
      this.cheap,
      this.veryPopular,
      this.sustainable,
      this.lowFodmap,
      this.weightWatcherSmartPoints,
      this.gaps,
      this.preparationMinutes,
      this.cookingMinutes,
      this.aggregateLikes,
      this.healthScore,
      this.creditsText,
      this.sourceName,
      this.pricePerServing,
      final List<ExtendedIngredient>? extendedIngredients,
      this.id,
      this.title,
      this.readyInMinutes,
      this.servings,
      this.sourceUrl,
      this.image,
      this.imageType,
      this.taste,
      this.summary,
      final List<dynamic>? cuisines,
      final List<String>? dishTypes,
      final List<String>? diets,
      final List<dynamic>? occasions,
      this.winePairing,
      this.instructions,
      final List<AnalyzedInstruction>? analyzedInstructions,
      this.originalId,
      this.spoonacularScore})
      : _extendedIngredients = extendedIngredients,
        _cuisines = cuisines,
        _dishTypes = dishTypes,
        _diets = diets,
        _occasions = occasions,
        _analyzedInstructions = analyzedInstructions;

  factory _$RecipeDetailsImpl.fromJson(Map<String, dynamic> json) =>
      _$$RecipeDetailsImplFromJson(json);

  @override
  final bool? vegetarian;
  @override
  final bool? vegan;
  @override
  final bool? glutenFree;
  @override
  final bool? dairyFree;
  @override
  final bool? veryHealthy;
  @override
  final bool? cheap;
  @override
  final bool? veryPopular;
  @override
  final bool? sustainable;
  @override
  final bool? lowFodmap;
  @override
  final int? weightWatcherSmartPoints;
  @override
  final String? gaps;
  @override
  final int? preparationMinutes;
  @override
  final int? cookingMinutes;
  @override
  final int? aggregateLikes;
  @override
  final int? healthScore;
  @override
  final String? creditsText;
  @override
  final String? sourceName;
  @override
  final double? pricePerServing;
  final List<ExtendedIngredient>? _extendedIngredients;
  @override
  List<ExtendedIngredient>? get extendedIngredients {
    final value = _extendedIngredients;
    if (value == null) return null;
    if (_extendedIngredients is EqualUnmodifiableListView)
      return _extendedIngredients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? id;
  @override
  final String? title;
  @override
  final int? readyInMinutes;
  @override
  final int? servings;
  @override
  final String? sourceUrl;
  @override
  final String? image;
  @override
  final String? imageType;
  @override
  final Taste? taste;
  @override
  final String? summary;
  final List<dynamic>? _cuisines;
  @override
  List<dynamic>? get cuisines {
    final value = _cuisines;
    if (value == null) return null;
    if (_cuisines is EqualUnmodifiableListView) return _cuisines;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _dishTypes;
  @override
  List<String>? get dishTypes {
    final value = _dishTypes;
    if (value == null) return null;
    if (_dishTypes is EqualUnmodifiableListView) return _dishTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _diets;
  @override
  List<String>? get diets {
    final value = _diets;
    if (value == null) return null;
    if (_diets is EqualUnmodifiableListView) return _diets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<dynamic>? _occasions;
  @override
  List<dynamic>? get occasions {
    final value = _occasions;
    if (value == null) return null;
    if (_occasions is EqualUnmodifiableListView) return _occasions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final WinePairing? winePairing;
  @override
  final String? instructions;
  final List<AnalyzedInstruction>? _analyzedInstructions;
  @override
  List<AnalyzedInstruction>? get analyzedInstructions {
    final value = _analyzedInstructions;
    if (value == null) return null;
    if (_analyzedInstructions is EqualUnmodifiableListView)
      return _analyzedInstructions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final dynamic originalId;
  @override
  final double? spoonacularScore;

  @override
  String toString() {
    return 'RecipeDetails(vegetarian: $vegetarian, vegan: $vegan, glutenFree: $glutenFree, dairyFree: $dairyFree, veryHealthy: $veryHealthy, cheap: $cheap, veryPopular: $veryPopular, sustainable: $sustainable, lowFodmap: $lowFodmap, weightWatcherSmartPoints: $weightWatcherSmartPoints, gaps: $gaps, preparationMinutes: $preparationMinutes, cookingMinutes: $cookingMinutes, aggregateLikes: $aggregateLikes, healthScore: $healthScore, creditsText: $creditsText, sourceName: $sourceName, pricePerServing: $pricePerServing, extendedIngredients: $extendedIngredients, id: $id, title: $title, readyInMinutes: $readyInMinutes, servings: $servings, sourceUrl: $sourceUrl, image: $image, imageType: $imageType, taste: $taste, summary: $summary, cuisines: $cuisines, dishTypes: $dishTypes, diets: $diets, occasions: $occasions, winePairing: $winePairing, instructions: $instructions, analyzedInstructions: $analyzedInstructions, originalId: $originalId, spoonacularScore: $spoonacularScore)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecipeDetailsImpl &&
            (identical(other.vegetarian, vegetarian) ||
                other.vegetarian == vegetarian) &&
            (identical(other.vegan, vegan) || other.vegan == vegan) &&
            (identical(other.glutenFree, glutenFree) ||
                other.glutenFree == glutenFree) &&
            (identical(other.dairyFree, dairyFree) ||
                other.dairyFree == dairyFree) &&
            (identical(other.veryHealthy, veryHealthy) ||
                other.veryHealthy == veryHealthy) &&
            (identical(other.cheap, cheap) || other.cheap == cheap) &&
            (identical(other.veryPopular, veryPopular) ||
                other.veryPopular == veryPopular) &&
            (identical(other.sustainable, sustainable) ||
                other.sustainable == sustainable) &&
            (identical(other.lowFodmap, lowFodmap) ||
                other.lowFodmap == lowFodmap) &&
            (identical(
                    other.weightWatcherSmartPoints, weightWatcherSmartPoints) ||
                other.weightWatcherSmartPoints == weightWatcherSmartPoints) &&
            (identical(other.gaps, gaps) || other.gaps == gaps) &&
            (identical(other.preparationMinutes, preparationMinutes) ||
                other.preparationMinutes == preparationMinutes) &&
            (identical(other.cookingMinutes, cookingMinutes) ||
                other.cookingMinutes == cookingMinutes) &&
            (identical(other.aggregateLikes, aggregateLikes) ||
                other.aggregateLikes == aggregateLikes) &&
            (identical(other.healthScore, healthScore) ||
                other.healthScore == healthScore) &&
            (identical(other.creditsText, creditsText) ||
                other.creditsText == creditsText) &&
            (identical(other.sourceName, sourceName) ||
                other.sourceName == sourceName) &&
            (identical(other.pricePerServing, pricePerServing) ||
                other.pricePerServing == pricePerServing) &&
            const DeepCollectionEquality()
                .equals(other._extendedIngredients, _extendedIngredients) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.readyInMinutes, readyInMinutes) ||
                other.readyInMinutes == readyInMinutes) &&
            (identical(other.servings, servings) ||
                other.servings == servings) &&
            (identical(other.sourceUrl, sourceUrl) ||
                other.sourceUrl == sourceUrl) &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.imageType, imageType) ||
                other.imageType == imageType) &&
            (identical(other.taste, taste) || other.taste == taste) &&
            (identical(other.summary, summary) || other.summary == summary) &&
            const DeepCollectionEquality().equals(other._cuisines, _cuisines) &&
            const DeepCollectionEquality()
                .equals(other._dishTypes, _dishTypes) &&
            const DeepCollectionEquality().equals(other._diets, _diets) &&
            const DeepCollectionEquality()
                .equals(other._occasions, _occasions) &&
            (identical(other.winePairing, winePairing) ||
                other.winePairing == winePairing) &&
            (identical(other.instructions, instructions) ||
                other.instructions == instructions) &&
            const DeepCollectionEquality()
                .equals(other._analyzedInstructions, _analyzedInstructions) &&
            const DeepCollectionEquality()
                .equals(other.originalId, originalId) &&
            (identical(other.spoonacularScore, spoonacularScore) ||
                other.spoonacularScore == spoonacularScore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        vegetarian,
        vegan,
        glutenFree,
        dairyFree,
        veryHealthy,
        cheap,
        veryPopular,
        sustainable,
        lowFodmap,
        weightWatcherSmartPoints,
        gaps,
        preparationMinutes,
        cookingMinutes,
        aggregateLikes,
        healthScore,
        creditsText,
        sourceName,
        pricePerServing,
        const DeepCollectionEquality().hash(_extendedIngredients),
        id,
        title,
        readyInMinutes,
        servings,
        sourceUrl,
        image,
        imageType,
        taste,
        summary,
        const DeepCollectionEquality().hash(_cuisines),
        const DeepCollectionEquality().hash(_dishTypes),
        const DeepCollectionEquality().hash(_diets),
        const DeepCollectionEquality().hash(_occasions),
        winePairing,
        instructions,
        const DeepCollectionEquality().hash(_analyzedInstructions),
        const DeepCollectionEquality().hash(originalId),
        spoonacularScore
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RecipeDetailsImplCopyWith<_$RecipeDetailsImpl> get copyWith =>
      __$$RecipeDetailsImplCopyWithImpl<_$RecipeDetailsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RecipeDetailsImplToJson(
      this,
    );
  }
}

abstract class _RecipeDetails implements RecipeDetails {
  const factory _RecipeDetails(
      {final bool? vegetarian,
      final bool? vegan,
      final bool? glutenFree,
      final bool? dairyFree,
      final bool? veryHealthy,
      final bool? cheap,
      final bool? veryPopular,
      final bool? sustainable,
      final bool? lowFodmap,
      final int? weightWatcherSmartPoints,
      final String? gaps,
      final int? preparationMinutes,
      final int? cookingMinutes,
      final int? aggregateLikes,
      final int? healthScore,
      final String? creditsText,
      final String? sourceName,
      final double? pricePerServing,
      final List<ExtendedIngredient>? extendedIngredients,
      final int? id,
      final String? title,
      final int? readyInMinutes,
      final int? servings,
      final String? sourceUrl,
      final String? image,
      final String? imageType,
      final Taste? taste,
      final String? summary,
      final List<dynamic>? cuisines,
      final List<String>? dishTypes,
      final List<String>? diets,
      final List<dynamic>? occasions,
      final WinePairing? winePairing,
      final String? instructions,
      final List<AnalyzedInstruction>? analyzedInstructions,
      final dynamic originalId,
      final double? spoonacularScore}) = _$RecipeDetailsImpl;

  factory _RecipeDetails.fromJson(Map<String, dynamic> json) =
      _$RecipeDetailsImpl.fromJson;

  @override
  bool? get vegetarian;
  @override
  bool? get vegan;
  @override
  bool? get glutenFree;
  @override
  bool? get dairyFree;
  @override
  bool? get veryHealthy;
  @override
  bool? get cheap;
  @override
  bool? get veryPopular;
  @override
  bool? get sustainable;
  @override
  bool? get lowFodmap;
  @override
  int? get weightWatcherSmartPoints;
  @override
  String? get gaps;
  @override
  int? get preparationMinutes;
  @override
  int? get cookingMinutes;
  @override
  int? get aggregateLikes;
  @override
  int? get healthScore;
  @override
  String? get creditsText;
  @override
  String? get sourceName;
  @override
  double? get pricePerServing;
  @override
  List<ExtendedIngredient>? get extendedIngredients;
  @override
  int? get id;
  @override
  String? get title;
  @override
  int? get readyInMinutes;
  @override
  int? get servings;
  @override
  String? get sourceUrl;
  @override
  String? get image;
  @override
  String? get imageType;
  @override
  Taste? get taste;
  @override
  String? get summary;
  @override
  List<dynamic>? get cuisines;
  @override
  List<String>? get dishTypes;
  @override
  List<String>? get diets;
  @override
  List<dynamic>? get occasions;
  @override
  WinePairing? get winePairing;
  @override
  String? get instructions;
  @override
  List<AnalyzedInstruction>? get analyzedInstructions;
  @override
  dynamic get originalId;
  @override
  double? get spoonacularScore;
  @override
  @JsonKey(ignore: true)
  _$$RecipeDetailsImplCopyWith<_$RecipeDetailsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AnalyzedInstruction _$AnalyzedInstructionFromJson(Map<String, dynamic> json) {
  return _AnalyzedInstruction.fromJson(json);
}

/// @nodoc
mixin _$AnalyzedInstruction {
  String? get name => throw _privateConstructorUsedError;
  List<Step>? get steps => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AnalyzedInstructionCopyWith<AnalyzedInstruction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyzedInstructionCopyWith<$Res> {
  factory $AnalyzedInstructionCopyWith(
          AnalyzedInstruction value, $Res Function(AnalyzedInstruction) then) =
      _$AnalyzedInstructionCopyWithImpl<$Res, AnalyzedInstruction>;
  @useResult
  $Res call({String? name, List<Step>? steps});
}

/// @nodoc
class _$AnalyzedInstructionCopyWithImpl<$Res, $Val extends AnalyzedInstruction>
    implements $AnalyzedInstructionCopyWith<$Res> {
  _$AnalyzedInstructionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? steps = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      steps: freezed == steps
          ? _value.steps
          : steps // ignore: cast_nullable_to_non_nullable
              as List<Step>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnalyzedInstructionImplCopyWith<$Res>
    implements $AnalyzedInstructionCopyWith<$Res> {
  factory _$$AnalyzedInstructionImplCopyWith(_$AnalyzedInstructionImpl value,
          $Res Function(_$AnalyzedInstructionImpl) then) =
      __$$AnalyzedInstructionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, List<Step>? steps});
}

/// @nodoc
class __$$AnalyzedInstructionImplCopyWithImpl<$Res>
    extends _$AnalyzedInstructionCopyWithImpl<$Res, _$AnalyzedInstructionImpl>
    implements _$$AnalyzedInstructionImplCopyWith<$Res> {
  __$$AnalyzedInstructionImplCopyWithImpl(_$AnalyzedInstructionImpl _value,
      $Res Function(_$AnalyzedInstructionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? steps = freezed,
  }) {
    return _then(_$AnalyzedInstructionImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      steps: freezed == steps
          ? _value._steps
          : steps // ignore: cast_nullable_to_non_nullable
              as List<Step>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AnalyzedInstructionImpl implements _AnalyzedInstruction {
  const _$AnalyzedInstructionImpl({this.name, final List<Step>? steps})
      : _steps = steps;

  factory _$AnalyzedInstructionImpl.fromJson(Map<String, dynamic> json) =>
      _$$AnalyzedInstructionImplFromJson(json);

  @override
  final String? name;
  final List<Step>? _steps;
  @override
  List<Step>? get steps {
    final value = _steps;
    if (value == null) return null;
    if (_steps is EqualUnmodifiableListView) return _steps;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AnalyzedInstruction(name: $name, steps: $steps)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalyzedInstructionImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._steps, _steps));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(_steps));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalyzedInstructionImplCopyWith<_$AnalyzedInstructionImpl> get copyWith =>
      __$$AnalyzedInstructionImplCopyWithImpl<_$AnalyzedInstructionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AnalyzedInstructionImplToJson(
      this,
    );
  }
}

abstract class _AnalyzedInstruction implements AnalyzedInstruction {
  const factory _AnalyzedInstruction(
      {final String? name,
      final List<Step>? steps}) = _$AnalyzedInstructionImpl;

  factory _AnalyzedInstruction.fromJson(Map<String, dynamic> json) =
      _$AnalyzedInstructionImpl.fromJson;

  @override
  String? get name;
  @override
  List<Step>? get steps;
  @override
  @JsonKey(ignore: true)
  _$$AnalyzedInstructionImplCopyWith<_$AnalyzedInstructionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Step _$StepFromJson(Map<String, dynamic> json) {
  return _Step.fromJson(json);
}

/// @nodoc
mixin _$Step {
  int? get number => throw _privateConstructorUsedError;
  String? get step => throw _privateConstructorUsedError;
  List<Ingredient>? get ingredients => throw _privateConstructorUsedError;
  List<dynamic>? get equipment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StepCopyWith<Step> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StepCopyWith<$Res> {
  factory $StepCopyWith(Step value, $Res Function(Step) then) =
      _$StepCopyWithImpl<$Res, Step>;
  @useResult
  $Res call(
      {int? number,
      String? step,
      List<Ingredient>? ingredients,
      List<dynamic>? equipment});
}

/// @nodoc
class _$StepCopyWithImpl<$Res, $Val extends Step>
    implements $StepCopyWith<$Res> {
  _$StepCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? step = freezed,
    Object? ingredients = freezed,
    Object? equipment = freezed,
  }) {
    return _then(_value.copyWith(
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      step: freezed == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as String?,
      ingredients: freezed == ingredients
          ? _value.ingredients
          : ingredients // ignore: cast_nullable_to_non_nullable
              as List<Ingredient>?,
      equipment: freezed == equipment
          ? _value.equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StepImplCopyWith<$Res> implements $StepCopyWith<$Res> {
  factory _$$StepImplCopyWith(
          _$StepImpl value, $Res Function(_$StepImpl) then) =
      __$$StepImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? number,
      String? step,
      List<Ingredient>? ingredients,
      List<dynamic>? equipment});
}

/// @nodoc
class __$$StepImplCopyWithImpl<$Res>
    extends _$StepCopyWithImpl<$Res, _$StepImpl>
    implements _$$StepImplCopyWith<$Res> {
  __$$StepImplCopyWithImpl(_$StepImpl _value, $Res Function(_$StepImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? number = freezed,
    Object? step = freezed,
    Object? ingredients = freezed,
    Object? equipment = freezed,
  }) {
    return _then(_$StepImpl(
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      step: freezed == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as String?,
      ingredients: freezed == ingredients
          ? _value._ingredients
          : ingredients // ignore: cast_nullable_to_non_nullable
              as List<Ingredient>?,
      equipment: freezed == equipment
          ? _value._equipment
          : equipment // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StepImpl implements _Step {
  const _$StepImpl(
      {this.number,
      this.step,
      final List<Ingredient>? ingredients,
      final List<dynamic>? equipment})
      : _ingredients = ingredients,
        _equipment = equipment;

  factory _$StepImpl.fromJson(Map<String, dynamic> json) =>
      _$$StepImplFromJson(json);

  @override
  final int? number;
  @override
  final String? step;
  final List<Ingredient>? _ingredients;
  @override
  List<Ingredient>? get ingredients {
    final value = _ingredients;
    if (value == null) return null;
    if (_ingredients is EqualUnmodifiableListView) return _ingredients;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<dynamic>? _equipment;
  @override
  List<dynamic>? get equipment {
    final value = _equipment;
    if (value == null) return null;
    if (_equipment is EqualUnmodifiableListView) return _equipment;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Step(number: $number, step: $step, ingredients: $ingredients, equipment: $equipment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StepImpl &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.step, step) || other.step == step) &&
            const DeepCollectionEquality()
                .equals(other._ingredients, _ingredients) &&
            const DeepCollectionEquality()
                .equals(other._equipment, _equipment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      number,
      step,
      const DeepCollectionEquality().hash(_ingredients),
      const DeepCollectionEquality().hash(_equipment));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StepImplCopyWith<_$StepImpl> get copyWith =>
      __$$StepImplCopyWithImpl<_$StepImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StepImplToJson(
      this,
    );
  }
}

abstract class _Step implements Step {
  const factory _Step(
      {final int? number,
      final String? step,
      final List<Ingredient>? ingredients,
      final List<dynamic>? equipment}) = _$StepImpl;

  factory _Step.fromJson(Map<String, dynamic> json) = _$StepImpl.fromJson;

  @override
  int? get number;
  @override
  String? get step;
  @override
  List<Ingredient>? get ingredients;
  @override
  List<dynamic>? get equipment;
  @override
  @JsonKey(ignore: true)
  _$$StepImplCopyWith<_$StepImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Ingredient _$IngredientFromJson(Map<String, dynamic> json) {
  return _Ingredient.fromJson(json);
}

/// @nodoc
mixin _$Ingredient {
  int? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get localizedName => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IngredientCopyWith<Ingredient> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IngredientCopyWith<$Res> {
  factory $IngredientCopyWith(
          Ingredient value, $Res Function(Ingredient) then) =
      _$IngredientCopyWithImpl<$Res, Ingredient>;
  @useResult
  $Res call({int? id, String? name, String? localizedName, String? image});
}

/// @nodoc
class _$IngredientCopyWithImpl<$Res, $Val extends Ingredient>
    implements $IngredientCopyWith<$Res> {
  _$IngredientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? localizedName = freezed,
    Object? image = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      localizedName: freezed == localizedName
          ? _value.localizedName
          : localizedName // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IngredientImplCopyWith<$Res>
    implements $IngredientCopyWith<$Res> {
  factory _$$IngredientImplCopyWith(
          _$IngredientImpl value, $Res Function(_$IngredientImpl) then) =
      __$$IngredientImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? id, String? name, String? localizedName, String? image});
}

/// @nodoc
class __$$IngredientImplCopyWithImpl<$Res>
    extends _$IngredientCopyWithImpl<$Res, _$IngredientImpl>
    implements _$$IngredientImplCopyWith<$Res> {
  __$$IngredientImplCopyWithImpl(
      _$IngredientImpl _value, $Res Function(_$IngredientImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? localizedName = freezed,
    Object? image = freezed,
  }) {
    return _then(_$IngredientImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      localizedName: freezed == localizedName
          ? _value.localizedName
          : localizedName // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$IngredientImpl implements _Ingredient {
  const _$IngredientImpl({this.id, this.name, this.localizedName, this.image});

  factory _$IngredientImpl.fromJson(Map<String, dynamic> json) =>
      _$$IngredientImplFromJson(json);

  @override
  final int? id;
  @override
  final String? name;
  @override
  final String? localizedName;
  @override
  final String? image;

  @override
  String toString() {
    return 'Ingredient(id: $id, name: $name, localizedName: $localizedName, image: $image)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IngredientImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.localizedName, localizedName) ||
                other.localizedName == localizedName) &&
            (identical(other.image, image) || other.image == image));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, localizedName, image);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IngredientImplCopyWith<_$IngredientImpl> get copyWith =>
      __$$IngredientImplCopyWithImpl<_$IngredientImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$IngredientImplToJson(
      this,
    );
  }
}

abstract class _Ingredient implements Ingredient {
  const factory _Ingredient(
      {final int? id,
      final String? name,
      final String? localizedName,
      final String? image}) = _$IngredientImpl;

  factory _Ingredient.fromJson(Map<String, dynamic> json) =
      _$IngredientImpl.fromJson;

  @override
  int? get id;
  @override
  String? get name;
  @override
  String? get localizedName;
  @override
  String? get image;
  @override
  @JsonKey(ignore: true)
  _$$IngredientImplCopyWith<_$IngredientImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ExtendedIngredient _$ExtendedIngredientFromJson(Map<String, dynamic> json) {
  return _ExtendedIngredient.fromJson(json);
}

/// @nodoc
mixin _$ExtendedIngredient {
  int? get id => throw _privateConstructorUsedError;
  String? get aisle => throw _privateConstructorUsedError;
  String? get image => throw _privateConstructorUsedError;
  String? get consistency => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get nameClean => throw _privateConstructorUsedError;
  String? get original => throw _privateConstructorUsedError;
  String? get originalName => throw _privateConstructorUsedError;
  int? get amount => throw _privateConstructorUsedError;
  String? get unit => throw _privateConstructorUsedError;
  List<dynamic>? get meta => throw _privateConstructorUsedError;
  Measures? get measures => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExtendedIngredientCopyWith<ExtendedIngredient> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExtendedIngredientCopyWith<$Res> {
  factory $ExtendedIngredientCopyWith(
          ExtendedIngredient value, $Res Function(ExtendedIngredient) then) =
      _$ExtendedIngredientCopyWithImpl<$Res, ExtendedIngredient>;
  @useResult
  $Res call(
      {int? id,
      String? aisle,
      String? image,
      String? consistency,
      String? name,
      String? nameClean,
      String? original,
      String? originalName,
      int? amount,
      String? unit,
      List<dynamic>? meta,
      Measures? measures});

  $MeasuresCopyWith<$Res>? get measures;
}

/// @nodoc
class _$ExtendedIngredientCopyWithImpl<$Res, $Val extends ExtendedIngredient>
    implements $ExtendedIngredientCopyWith<$Res> {
  _$ExtendedIngredientCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? aisle = freezed,
    Object? image = freezed,
    Object? consistency = freezed,
    Object? name = freezed,
    Object? nameClean = freezed,
    Object? original = freezed,
    Object? originalName = freezed,
    Object? amount = freezed,
    Object? unit = freezed,
    Object? meta = freezed,
    Object? measures = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      aisle: freezed == aisle
          ? _value.aisle
          : aisle // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      consistency: freezed == consistency
          ? _value.consistency
          : consistency // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameClean: freezed == nameClean
          ? _value.nameClean
          : nameClean // ignore: cast_nullable_to_non_nullable
              as String?,
      original: freezed == original
          ? _value.original
          : original // ignore: cast_nullable_to_non_nullable
              as String?,
      originalName: freezed == originalName
          ? _value.originalName
          : originalName // ignore: cast_nullable_to_non_nullable
              as String?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      measures: freezed == measures
          ? _value.measures
          : measures // ignore: cast_nullable_to_non_nullable
              as Measures?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MeasuresCopyWith<$Res>? get measures {
    if (_value.measures == null) {
      return null;
    }

    return $MeasuresCopyWith<$Res>(_value.measures!, (value) {
      return _then(_value.copyWith(measures: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExtendedIngredientImplCopyWith<$Res>
    implements $ExtendedIngredientCopyWith<$Res> {
  factory _$$ExtendedIngredientImplCopyWith(_$ExtendedIngredientImpl value,
          $Res Function(_$ExtendedIngredientImpl) then) =
      __$$ExtendedIngredientImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? id,
      String? aisle,
      String? image,
      String? consistency,
      String? name,
      String? nameClean,
      String? original,
      String? originalName,
      int? amount,
      String? unit,
      List<dynamic>? meta,
      Measures? measures});

  @override
  $MeasuresCopyWith<$Res>? get measures;
}

/// @nodoc
class __$$ExtendedIngredientImplCopyWithImpl<$Res>
    extends _$ExtendedIngredientCopyWithImpl<$Res, _$ExtendedIngredientImpl>
    implements _$$ExtendedIngredientImplCopyWith<$Res> {
  __$$ExtendedIngredientImplCopyWithImpl(_$ExtendedIngredientImpl _value,
      $Res Function(_$ExtendedIngredientImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? aisle = freezed,
    Object? image = freezed,
    Object? consistency = freezed,
    Object? name = freezed,
    Object? nameClean = freezed,
    Object? original = freezed,
    Object? originalName = freezed,
    Object? amount = freezed,
    Object? unit = freezed,
    Object? meta = freezed,
    Object? measures = freezed,
  }) {
    return _then(_$ExtendedIngredientImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      aisle: freezed == aisle
          ? _value.aisle
          : aisle // ignore: cast_nullable_to_non_nullable
              as String?,
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      consistency: freezed == consistency
          ? _value.consistency
          : consistency // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameClean: freezed == nameClean
          ? _value.nameClean
          : nameClean // ignore: cast_nullable_to_non_nullable
              as String?,
      original: freezed == original
          ? _value.original
          : original // ignore: cast_nullable_to_non_nullable
              as String?,
      originalName: freezed == originalName
          ? _value.originalName
          : originalName // ignore: cast_nullable_to_non_nullable
              as String?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value._meta
          : meta // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      measures: freezed == measures
          ? _value.measures
          : measures // ignore: cast_nullable_to_non_nullable
              as Measures?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExtendedIngredientImpl implements _ExtendedIngredient {
  const _$ExtendedIngredientImpl(
      {this.id,
      this.aisle,
      this.image,
      this.consistency,
      this.name,
      this.nameClean,
      this.original,
      this.originalName,
      this.amount,
      this.unit,
      final List<dynamic>? meta,
      this.measures})
      : _meta = meta;

  factory _$ExtendedIngredientImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExtendedIngredientImplFromJson(json);

  @override
  final int? id;
  @override
  final String? aisle;
  @override
  final String? image;
  @override
  final String? consistency;
  @override
  final String? name;
  @override
  final String? nameClean;
  @override
  final String? original;
  @override
  final String? originalName;
  @override
  final int? amount;
  @override
  final String? unit;
  final List<dynamic>? _meta;
  @override
  List<dynamic>? get meta {
    final value = _meta;
    if (value == null) return null;
    if (_meta is EqualUnmodifiableListView) return _meta;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Measures? measures;

  @override
  String toString() {
    return 'ExtendedIngredient(id: $id, aisle: $aisle, image: $image, consistency: $consistency, name: $name, nameClean: $nameClean, original: $original, originalName: $originalName, amount: $amount, unit: $unit, meta: $meta, measures: $measures)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExtendedIngredientImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.aisle, aisle) || other.aisle == aisle) &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.consistency, consistency) ||
                other.consistency == consistency) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameClean, nameClean) ||
                other.nameClean == nameClean) &&
            (identical(other.original, original) ||
                other.original == original) &&
            (identical(other.originalName, originalName) ||
                other.originalName == originalName) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            const DeepCollectionEquality().equals(other._meta, _meta) &&
            (identical(other.measures, measures) ||
                other.measures == measures));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      aisle,
      image,
      consistency,
      name,
      nameClean,
      original,
      originalName,
      amount,
      unit,
      const DeepCollectionEquality().hash(_meta),
      measures);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExtendedIngredientImplCopyWith<_$ExtendedIngredientImpl> get copyWith =>
      __$$ExtendedIngredientImplCopyWithImpl<_$ExtendedIngredientImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExtendedIngredientImplToJson(
      this,
    );
  }
}

abstract class _ExtendedIngredient implements ExtendedIngredient {
  const factory _ExtendedIngredient(
      {final int? id,
      final String? aisle,
      final String? image,
      final String? consistency,
      final String? name,
      final String? nameClean,
      final String? original,
      final String? originalName,
      final int? amount,
      final String? unit,
      final List<dynamic>? meta,
      final Measures? measures}) = _$ExtendedIngredientImpl;

  factory _ExtendedIngredient.fromJson(Map<String, dynamic> json) =
      _$ExtendedIngredientImpl.fromJson;

  @override
  int? get id;
  @override
  String? get aisle;
  @override
  String? get image;
  @override
  String? get consistency;
  @override
  String? get name;
  @override
  String? get nameClean;
  @override
  String? get original;
  @override
  String? get originalName;
  @override
  int? get amount;
  @override
  String? get unit;
  @override
  List<dynamic>? get meta;
  @override
  Measures? get measures;
  @override
  @JsonKey(ignore: true)
  _$$ExtendedIngredientImplCopyWith<_$ExtendedIngredientImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Measures _$MeasuresFromJson(Map<String, dynamic> json) {
  return _Measures.fromJson(json);
}

/// @nodoc
mixin _$Measures {
  Us? get us => throw _privateConstructorUsedError;
  Metric? get metric => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MeasuresCopyWith<Measures> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasuresCopyWith<$Res> {
  factory $MeasuresCopyWith(Measures value, $Res Function(Measures) then) =
      _$MeasuresCopyWithImpl<$Res, Measures>;
  @useResult
  $Res call({Us? us, Metric? metric});

  $UsCopyWith<$Res>? get us;
  $MetricCopyWith<$Res>? get metric;
}

/// @nodoc
class _$MeasuresCopyWithImpl<$Res, $Val extends Measures>
    implements $MeasuresCopyWith<$Res> {
  _$MeasuresCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? us = freezed,
    Object? metric = freezed,
  }) {
    return _then(_value.copyWith(
      us: freezed == us
          ? _value.us
          : us // ignore: cast_nullable_to_non_nullable
              as Us?,
      metric: freezed == metric
          ? _value.metric
          : metric // ignore: cast_nullable_to_non_nullable
              as Metric?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UsCopyWith<$Res>? get us {
    if (_value.us == null) {
      return null;
    }

    return $UsCopyWith<$Res>(_value.us!, (value) {
      return _then(_value.copyWith(us: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MetricCopyWith<$Res>? get metric {
    if (_value.metric == null) {
      return null;
    }

    return $MetricCopyWith<$Res>(_value.metric!, (value) {
      return _then(_value.copyWith(metric: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MeasuresImplCopyWith<$Res>
    implements $MeasuresCopyWith<$Res> {
  factory _$$MeasuresImplCopyWith(
          _$MeasuresImpl value, $Res Function(_$MeasuresImpl) then) =
      __$$MeasuresImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Us? us, Metric? metric});

  @override
  $UsCopyWith<$Res>? get us;
  @override
  $MetricCopyWith<$Res>? get metric;
}

/// @nodoc
class __$$MeasuresImplCopyWithImpl<$Res>
    extends _$MeasuresCopyWithImpl<$Res, _$MeasuresImpl>
    implements _$$MeasuresImplCopyWith<$Res> {
  __$$MeasuresImplCopyWithImpl(
      _$MeasuresImpl _value, $Res Function(_$MeasuresImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? us = freezed,
    Object? metric = freezed,
  }) {
    return _then(_$MeasuresImpl(
      us: freezed == us
          ? _value.us
          : us // ignore: cast_nullable_to_non_nullable
              as Us?,
      metric: freezed == metric
          ? _value.metric
          : metric // ignore: cast_nullable_to_non_nullable
              as Metric?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MeasuresImpl implements _Measures {
  const _$MeasuresImpl({this.us, this.metric});

  factory _$MeasuresImpl.fromJson(Map<String, dynamic> json) =>
      _$$MeasuresImplFromJson(json);

  @override
  final Us? us;
  @override
  final Metric? metric;

  @override
  String toString() {
    return 'Measures(us: $us, metric: $metric)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasuresImpl &&
            (identical(other.us, us) || other.us == us) &&
            (identical(other.metric, metric) || other.metric == metric));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, us, metric);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MeasuresImplCopyWith<_$MeasuresImpl> get copyWith =>
      __$$MeasuresImplCopyWithImpl<_$MeasuresImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MeasuresImplToJson(
      this,
    );
  }
}

abstract class _Measures implements Measures {
  const factory _Measures({final Us? us, final Metric? metric}) =
      _$MeasuresImpl;

  factory _Measures.fromJson(Map<String, dynamic> json) =
      _$MeasuresImpl.fromJson;

  @override
  Us? get us;
  @override
  Metric? get metric;
  @override
  @JsonKey(ignore: true)
  _$$MeasuresImplCopyWith<_$MeasuresImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Metric _$MetricFromJson(Map<String, dynamic> json) {
  return _Metric.fromJson(json);
}

/// @nodoc
mixin _$Metric {
  int? get amount => throw _privateConstructorUsedError;
  String? get unitShort => throw _privateConstructorUsedError;
  String? get unitLong => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MetricCopyWith<Metric> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetricCopyWith<$Res> {
  factory $MetricCopyWith(Metric value, $Res Function(Metric) then) =
      _$MetricCopyWithImpl<$Res, Metric>;
  @useResult
  $Res call({int? amount, String? unitShort, String? unitLong});
}

/// @nodoc
class _$MetricCopyWithImpl<$Res, $Val extends Metric>
    implements $MetricCopyWith<$Res> {
  _$MetricCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = freezed,
    Object? unitShort = freezed,
    Object? unitLong = freezed,
  }) {
    return _then(_value.copyWith(
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
      unitShort: freezed == unitShort
          ? _value.unitShort
          : unitShort // ignore: cast_nullable_to_non_nullable
              as String?,
      unitLong: freezed == unitLong
          ? _value.unitLong
          : unitLong // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MetricImplCopyWith<$Res> implements $MetricCopyWith<$Res> {
  factory _$$MetricImplCopyWith(
          _$MetricImpl value, $Res Function(_$MetricImpl) then) =
      __$$MetricImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? amount, String? unitShort, String? unitLong});
}

/// @nodoc
class __$$MetricImplCopyWithImpl<$Res>
    extends _$MetricCopyWithImpl<$Res, _$MetricImpl>
    implements _$$MetricImplCopyWith<$Res> {
  __$$MetricImplCopyWithImpl(
      _$MetricImpl _value, $Res Function(_$MetricImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = freezed,
    Object? unitShort = freezed,
    Object? unitLong = freezed,
  }) {
    return _then(_$MetricImpl(
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
      unitShort: freezed == unitShort
          ? _value.unitShort
          : unitShort // ignore: cast_nullable_to_non_nullable
              as String?,
      unitLong: freezed == unitLong
          ? _value.unitLong
          : unitLong // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MetricImpl implements _Metric {
  const _$MetricImpl({this.amount, this.unitShort, this.unitLong});

  factory _$MetricImpl.fromJson(Map<String, dynamic> json) =>
      _$$MetricImplFromJson(json);

  @override
  final int? amount;
  @override
  final String? unitShort;
  @override
  final String? unitLong;

  @override
  String toString() {
    return 'Metric(amount: $amount, unitShort: $unitShort, unitLong: $unitLong)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MetricImpl &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.unitShort, unitShort) ||
                other.unitShort == unitShort) &&
            (identical(other.unitLong, unitLong) ||
                other.unitLong == unitLong));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, amount, unitShort, unitLong);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MetricImplCopyWith<_$MetricImpl> get copyWith =>
      __$$MetricImplCopyWithImpl<_$MetricImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MetricImplToJson(
      this,
    );
  }
}

abstract class _Metric implements Metric {
  const factory _Metric(
      {final int? amount,
      final String? unitShort,
      final String? unitLong}) = _$MetricImpl;

  factory _Metric.fromJson(Map<String, dynamic> json) = _$MetricImpl.fromJson;

  @override
  int? get amount;
  @override
  String? get unitShort;
  @override
  String? get unitLong;
  @override
  @JsonKey(ignore: true)
  _$$MetricImplCopyWith<_$MetricImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Us _$UsFromJson(Map<String, dynamic> json) {
  return _Us.fromJson(json);
}

/// @nodoc
mixin _$Us {
  double? get amount => throw _privateConstructorUsedError;
  String? get unitShort => throw _privateConstructorUsedError;
  String? get unitLong => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UsCopyWith<Us> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UsCopyWith<$Res> {
  factory $UsCopyWith(Us value, $Res Function(Us) then) =
      _$UsCopyWithImpl<$Res, Us>;
  @useResult
  $Res call({double? amount, String? unitShort, String? unitLong});
}

/// @nodoc
class _$UsCopyWithImpl<$Res, $Val extends Us> implements $UsCopyWith<$Res> {
  _$UsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = freezed,
    Object? unitShort = freezed,
    Object? unitLong = freezed,
  }) {
    return _then(_value.copyWith(
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double?,
      unitShort: freezed == unitShort
          ? _value.unitShort
          : unitShort // ignore: cast_nullable_to_non_nullable
              as String?,
      unitLong: freezed == unitLong
          ? _value.unitLong
          : unitLong // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UsImplCopyWith<$Res> implements $UsCopyWith<$Res> {
  factory _$$UsImplCopyWith(_$UsImpl value, $Res Function(_$UsImpl) then) =
      __$$UsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double? amount, String? unitShort, String? unitLong});
}

/// @nodoc
class __$$UsImplCopyWithImpl<$Res> extends _$UsCopyWithImpl<$Res, _$UsImpl>
    implements _$$UsImplCopyWith<$Res> {
  __$$UsImplCopyWithImpl(_$UsImpl _value, $Res Function(_$UsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? amount = freezed,
    Object? unitShort = freezed,
    Object? unitLong = freezed,
  }) {
    return _then(_$UsImpl(
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double?,
      unitShort: freezed == unitShort
          ? _value.unitShort
          : unitShort // ignore: cast_nullable_to_non_nullable
              as String?,
      unitLong: freezed == unitLong
          ? _value.unitLong
          : unitLong // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UsImpl implements _Us {
  const _$UsImpl({this.amount, this.unitShort, this.unitLong});

  factory _$UsImpl.fromJson(Map<String, dynamic> json) =>
      _$$UsImplFromJson(json);

  @override
  final double? amount;
  @override
  final String? unitShort;
  @override
  final String? unitLong;

  @override
  String toString() {
    return 'Us(amount: $amount, unitShort: $unitShort, unitLong: $unitLong)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UsImpl &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.unitShort, unitShort) ||
                other.unitShort == unitShort) &&
            (identical(other.unitLong, unitLong) ||
                other.unitLong == unitLong));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, amount, unitShort, unitLong);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UsImplCopyWith<_$UsImpl> get copyWith =>
      __$$UsImplCopyWithImpl<_$UsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UsImplToJson(
      this,
    );
  }
}

abstract class _Us implements Us {
  const factory _Us(
      {final double? amount,
      final String? unitShort,
      final String? unitLong}) = _$UsImpl;

  factory _Us.fromJson(Map<String, dynamic> json) = _$UsImpl.fromJson;

  @override
  double? get amount;
  @override
  String? get unitShort;
  @override
  String? get unitLong;
  @override
  @JsonKey(ignore: true)
  _$$UsImplCopyWith<_$UsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Taste _$TasteFromJson(Map<String, dynamic> json) {
  return _Taste.fromJson(json);
}

/// @nodoc
mixin _$Taste {
  double? get sweetness => throw _privateConstructorUsedError;
  double? get saltiness => throw _privateConstructorUsedError;
  double? get sourness => throw _privateConstructorUsedError;
  int? get bitterness => throw _privateConstructorUsedError;
  int? get savoriness => throw _privateConstructorUsedError;
  double? get fattiness => throw _privateConstructorUsedError;
  int? get spiciness => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TasteCopyWith<Taste> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TasteCopyWith<$Res> {
  factory $TasteCopyWith(Taste value, $Res Function(Taste) then) =
      _$TasteCopyWithImpl<$Res, Taste>;
  @useResult
  $Res call(
      {double? sweetness,
      double? saltiness,
      double? sourness,
      int? bitterness,
      int? savoriness,
      double? fattiness,
      int? spiciness});
}

/// @nodoc
class _$TasteCopyWithImpl<$Res, $Val extends Taste>
    implements $TasteCopyWith<$Res> {
  _$TasteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sweetness = freezed,
    Object? saltiness = freezed,
    Object? sourness = freezed,
    Object? bitterness = freezed,
    Object? savoriness = freezed,
    Object? fattiness = freezed,
    Object? spiciness = freezed,
  }) {
    return _then(_value.copyWith(
      sweetness: freezed == sweetness
          ? _value.sweetness
          : sweetness // ignore: cast_nullable_to_non_nullable
              as double?,
      saltiness: freezed == saltiness
          ? _value.saltiness
          : saltiness // ignore: cast_nullable_to_non_nullable
              as double?,
      sourness: freezed == sourness
          ? _value.sourness
          : sourness // ignore: cast_nullable_to_non_nullable
              as double?,
      bitterness: freezed == bitterness
          ? _value.bitterness
          : bitterness // ignore: cast_nullable_to_non_nullable
              as int?,
      savoriness: freezed == savoriness
          ? _value.savoriness
          : savoriness // ignore: cast_nullable_to_non_nullable
              as int?,
      fattiness: freezed == fattiness
          ? _value.fattiness
          : fattiness // ignore: cast_nullable_to_non_nullable
              as double?,
      spiciness: freezed == spiciness
          ? _value.spiciness
          : spiciness // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TasteImplCopyWith<$Res> implements $TasteCopyWith<$Res> {
  factory _$$TasteImplCopyWith(
          _$TasteImpl value, $Res Function(_$TasteImpl) then) =
      __$$TasteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? sweetness,
      double? saltiness,
      double? sourness,
      int? bitterness,
      int? savoriness,
      double? fattiness,
      int? spiciness});
}

/// @nodoc
class __$$TasteImplCopyWithImpl<$Res>
    extends _$TasteCopyWithImpl<$Res, _$TasteImpl>
    implements _$$TasteImplCopyWith<$Res> {
  __$$TasteImplCopyWithImpl(
      _$TasteImpl _value, $Res Function(_$TasteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sweetness = freezed,
    Object? saltiness = freezed,
    Object? sourness = freezed,
    Object? bitterness = freezed,
    Object? savoriness = freezed,
    Object? fattiness = freezed,
    Object? spiciness = freezed,
  }) {
    return _then(_$TasteImpl(
      sweetness: freezed == sweetness
          ? _value.sweetness
          : sweetness // ignore: cast_nullable_to_non_nullable
              as double?,
      saltiness: freezed == saltiness
          ? _value.saltiness
          : saltiness // ignore: cast_nullable_to_non_nullable
              as double?,
      sourness: freezed == sourness
          ? _value.sourness
          : sourness // ignore: cast_nullable_to_non_nullable
              as double?,
      bitterness: freezed == bitterness
          ? _value.bitterness
          : bitterness // ignore: cast_nullable_to_non_nullable
              as int?,
      savoriness: freezed == savoriness
          ? _value.savoriness
          : savoriness // ignore: cast_nullable_to_non_nullable
              as int?,
      fattiness: freezed == fattiness
          ? _value.fattiness
          : fattiness // ignore: cast_nullable_to_non_nullable
              as double?,
      spiciness: freezed == spiciness
          ? _value.spiciness
          : spiciness // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TasteImpl implements _Taste {
  const _$TasteImpl(
      {this.sweetness,
      this.saltiness,
      this.sourness,
      this.bitterness,
      this.savoriness,
      this.fattiness,
      this.spiciness});

  factory _$TasteImpl.fromJson(Map<String, dynamic> json) =>
      _$$TasteImplFromJson(json);

  @override
  final double? sweetness;
  @override
  final double? saltiness;
  @override
  final double? sourness;
  @override
  final int? bitterness;
  @override
  final int? savoriness;
  @override
  final double? fattiness;
  @override
  final int? spiciness;

  @override
  String toString() {
    return 'Taste(sweetness: $sweetness, saltiness: $saltiness, sourness: $sourness, bitterness: $bitterness, savoriness: $savoriness, fattiness: $fattiness, spiciness: $spiciness)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TasteImpl &&
            (identical(other.sweetness, sweetness) ||
                other.sweetness == sweetness) &&
            (identical(other.saltiness, saltiness) ||
                other.saltiness == saltiness) &&
            (identical(other.sourness, sourness) ||
                other.sourness == sourness) &&
            (identical(other.bitterness, bitterness) ||
                other.bitterness == bitterness) &&
            (identical(other.savoriness, savoriness) ||
                other.savoriness == savoriness) &&
            (identical(other.fattiness, fattiness) ||
                other.fattiness == fattiness) &&
            (identical(other.spiciness, spiciness) ||
                other.spiciness == spiciness));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, sweetness, saltiness, sourness,
      bitterness, savoriness, fattiness, spiciness);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TasteImplCopyWith<_$TasteImpl> get copyWith =>
      __$$TasteImplCopyWithImpl<_$TasteImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TasteImplToJson(
      this,
    );
  }
}

abstract class _Taste implements Taste {
  const factory _Taste(
      {final double? sweetness,
      final double? saltiness,
      final double? sourness,
      final int? bitterness,
      final int? savoriness,
      final double? fattiness,
      final int? spiciness}) = _$TasteImpl;

  factory _Taste.fromJson(Map<String, dynamic> json) = _$TasteImpl.fromJson;

  @override
  double? get sweetness;
  @override
  double? get saltiness;
  @override
  double? get sourness;
  @override
  int? get bitterness;
  @override
  int? get savoriness;
  @override
  double? get fattiness;
  @override
  int? get spiciness;
  @override
  @JsonKey(ignore: true)
  _$$TasteImplCopyWith<_$TasteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

WinePairing _$WinePairingFromJson(Map<String, dynamic> json) {
  return _WinePairing.fromJson(json);
}

/// @nodoc
mixin _$WinePairing {
  List<dynamic>? get pairedWines => throw _privateConstructorUsedError;
  String? get pairingText => throw _privateConstructorUsedError;
  List<dynamic>? get productMatches => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WinePairingCopyWith<WinePairing> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WinePairingCopyWith<$Res> {
  factory $WinePairingCopyWith(
          WinePairing value, $Res Function(WinePairing) then) =
      _$WinePairingCopyWithImpl<$Res, WinePairing>;
  @useResult
  $Res call(
      {List<dynamic>? pairedWines,
      String? pairingText,
      List<dynamic>? productMatches});
}

/// @nodoc
class _$WinePairingCopyWithImpl<$Res, $Val extends WinePairing>
    implements $WinePairingCopyWith<$Res> {
  _$WinePairingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pairedWines = freezed,
    Object? pairingText = freezed,
    Object? productMatches = freezed,
  }) {
    return _then(_value.copyWith(
      pairedWines: freezed == pairedWines
          ? _value.pairedWines
          : pairedWines // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      pairingText: freezed == pairingText
          ? _value.pairingText
          : pairingText // ignore: cast_nullable_to_non_nullable
              as String?,
      productMatches: freezed == productMatches
          ? _value.productMatches
          : productMatches // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WinePairingImplCopyWith<$Res>
    implements $WinePairingCopyWith<$Res> {
  factory _$$WinePairingImplCopyWith(
          _$WinePairingImpl value, $Res Function(_$WinePairingImpl) then) =
      __$$WinePairingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<dynamic>? pairedWines,
      String? pairingText,
      List<dynamic>? productMatches});
}

/// @nodoc
class __$$WinePairingImplCopyWithImpl<$Res>
    extends _$WinePairingCopyWithImpl<$Res, _$WinePairingImpl>
    implements _$$WinePairingImplCopyWith<$Res> {
  __$$WinePairingImplCopyWithImpl(
      _$WinePairingImpl _value, $Res Function(_$WinePairingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pairedWines = freezed,
    Object? pairingText = freezed,
    Object? productMatches = freezed,
  }) {
    return _then(_$WinePairingImpl(
      pairedWines: freezed == pairedWines
          ? _value._pairedWines
          : pairedWines // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      pairingText: freezed == pairingText
          ? _value.pairingText
          : pairingText // ignore: cast_nullable_to_non_nullable
              as String?,
      productMatches: freezed == productMatches
          ? _value._productMatches
          : productMatches // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WinePairingImpl implements _WinePairing {
  const _$WinePairingImpl(
      {final List<dynamic>? pairedWines,
      this.pairingText,
      final List<dynamic>? productMatches})
      : _pairedWines = pairedWines,
        _productMatches = productMatches;

  factory _$WinePairingImpl.fromJson(Map<String, dynamic> json) =>
      _$$WinePairingImplFromJson(json);

  final List<dynamic>? _pairedWines;
  @override
  List<dynamic>? get pairedWines {
    final value = _pairedWines;
    if (value == null) return null;
    if (_pairedWines is EqualUnmodifiableListView) return _pairedWines;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? pairingText;
  final List<dynamic>? _productMatches;
  @override
  List<dynamic>? get productMatches {
    final value = _productMatches;
    if (value == null) return null;
    if (_productMatches is EqualUnmodifiableListView) return _productMatches;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'WinePairing(pairedWines: $pairedWines, pairingText: $pairingText, productMatches: $productMatches)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WinePairingImpl &&
            const DeepCollectionEquality()
                .equals(other._pairedWines, _pairedWines) &&
            (identical(other.pairingText, pairingText) ||
                other.pairingText == pairingText) &&
            const DeepCollectionEquality()
                .equals(other._productMatches, _productMatches));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_pairedWines),
      pairingText,
      const DeepCollectionEquality().hash(_productMatches));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WinePairingImplCopyWith<_$WinePairingImpl> get copyWith =>
      __$$WinePairingImplCopyWithImpl<_$WinePairingImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WinePairingImplToJson(
      this,
    );
  }
}

abstract class _WinePairing implements WinePairing {
  const factory _WinePairing(
      {final List<dynamic>? pairedWines,
      final String? pairingText,
      final List<dynamic>? productMatches}) = _$WinePairingImpl;

  factory _WinePairing.fromJson(Map<String, dynamic> json) =
      _$WinePairingImpl.fromJson;

  @override
  List<dynamic>? get pairedWines;
  @override
  String? get pairingText;
  @override
  List<dynamic>? get productMatches;
  @override
  @JsonKey(ignore: true)
  _$$WinePairingImplCopyWith<_$WinePairingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
